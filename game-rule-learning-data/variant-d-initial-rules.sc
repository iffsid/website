(define (variant-d-initial-board) '(1 ((1 1 1) (0 0 0) (-1 -1 -1))))

(define (variant-d-board-move board from-i from-j to-i to-j)
 (list-2d-replace
  (list-2d-replace board to-i to-j (list-2d-ref board from-i from-j))
  from-i
  from-j
  0))

(define (variant-d-moves board)
 (define (variant-d-piece-at i j board) (list-2d-ref board i j))
 (define (variant-d-piece-at? i j board) (not (zero? (list-2d-ref board i j))))
 (define (variant-d-on-board? i board) (and (>= i 0) (< i (length board))))
 (define (variant-d-can-capture? piece direction i j board)
  (and (variant-d-on-board? (+ i piece) board)
       (variant-d-on-board? (+ j direction) board)
       (variant-d-piece-at? (+ i piece) (+ j direction) board)
       (not (eq? (variant-d-piece-at (+ i piece) (+ j direction) board) piece))))
 (define (variant-d-can-capture-l? piece i j board)
  (variant-d-can-capture? piece 1 i j board))
 (define (variant-d-can-capture-r? piece i j board)
  (variant-d-can-capture? piece -1 i j board))
 (define (variant-d-move-forward? piece i j board)
  (and (variant-d-on-board? (+ i piece) board)
       (not (variant-d-piece-at? (+ i piece) j board))))
 (define (variant-d-move-backward? piece i j pieces)
  (and (variant-d-on-board? (- i piece) pieces)
       (not (variant-d-piece-at? (- i piece) j pieces))))
 (define (variant-d-move-left? piece i j pieces)
  (and (variant-d-on-board? (- j 1) pieces)
       (not (variant-d-piece-at? i (- j 1) pieces))))
 (define (variant-d-move-right? piece i j pieces)
  (and (variant-d-on-board? (+ j 1) pieces)
       (not (variant-d-piece-at? i (+ j 1) pieces))))
 (define (variant-d-move-sideways? piece direction i j pieces)
  (and (variant-d-on-board? (+ i piece) pieces)
       (variant-d-on-board? (+ j direction) pieces)
       (not (variant-d-piece-at? (+ i piece) (+ j direction) pieces))))
 (define (variant-d-move-back-sideways? piece direction i j pieces)
  (and (variant-d-on-board? (- i piece) pieces)
       (variant-d-on-board? (+ j direction) pieces)
       (not (variant-d-piece-at? (- i piece) (+ j direction) pieces))))
 (let* ((player (first board)) (board (second board)) (n (length board)))
  (map
   (lambda (x) `(,(- player) ,x))
   (reduce
    append
    (map-indexed
     (lambda (row i)
      (reduce
       append
       (map-indexed
	(lambda (piece j)
	 (if (= piece player)
	     (append
	      (if (variant-d-move-forward? piece i j board)
		  `(,(variant-d-board-move board i j (+ i piece) j))
		  '())
	      (if (variant-d-move-backward? piece i j board)
		  `(,(variant-d-board-move board i j (- i piece) j))
		  '())
	      (if (variant-d-move-left? piece i j board)
		  `(,(variant-d-board-move board i j i (- j 1)))
		  '())
	      (if (variant-d-move-right? piece i j board)
		  `(,(variant-d-board-move board i j i (+ j 1)))
		  '())
	      (if (variant-d-can-capture-l? piece i j board)
		  `(,(variant-d-board-move board i j (+ i piece) (+ j 1)))
		  '())
	      (if (variant-d-can-capture-r? piece i j board)
		  `(,(variant-d-board-move board i j (+ i piece) (- j 1)))
		  '()))
	     '()))
	row)
       '()))
     board)
    '()))))

(define (variant-d-win0 board)
 (cond ((some (lambda (current) (= current 1)) (last (second board))) 1)
       ((some (lambda (current) (= current -1)) (first (second board))) -1)
       ((null? (variant-d-moves board)) (- (first board)))
       (else 0)))
